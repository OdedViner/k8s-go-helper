
// package exec

// import (
// 	"bytes"
// 	"context"
// 	"fmt"
// 	"io"
// 	"os"
// 	"strings"

// 	v1 "k8s.io/api/core/v1"
// 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
// 	"k8s.io/client-go/kubernetes/scheme"
// 	"k8s.io/client-go/tools/remotecommand"
// 	"k8s.io/client-go/kubernetes"

// 	"k8s.io/client-go/tools/clientcmd"
// 	rookclient "github.com/rook/rook/pkg/client/clientset/versioned"
// 	k8s "k8s.io/client-go/kubernetes"
// 	"k8s.io/client-go/dynamic"
// 	discovery "k8s.io/client-go/discovery"
// 	rest "k8s.io/client-go/rest"
// 	flowcontrol "k8s.io/client-go/util/flowcontrol"


	
// )

// type CephV1Client struct {
// 	restClient rest.Interface
// }

// // Clientset contains the clients for groups. Each group has exactly one
// // version included in a Clientset.
// type Clientset struct {
// 	*discovery.DiscoveryClient
// 	cephV1 CephV1Client
// }


// type Interface interface {
// 	Discovery() discovery.DiscoveryInterface
// 	CephV1() CephV1Interface
// }

// type CephV1Interface interface {
// 	RESTClient() rest.Interface
// 	CephBlockPoolsGetter
// 	CephBlockPoolRadosNamespacesGetter
// 	CephBucketNotificationsGetter
// 	CephBucketTopicsGetter
// 	CephCOSIDriversGetter
// 	CephClientsGetter
// 	CephClustersGetter
// 	CephFilesystemsGetter
// 	CephFilesystemMirrorsGetter
// 	CephFilesystemSubVolumeGroupsGetter
// 	CephNFSesGetter
// 	CephObjectRealmsGetter
// 	CephObjectStoresGetter
// 	CephObjectStoreUsersGetter
// 	CephObjectZonesGetter
// 	CephObjectZoneGroupsGetter
// 	CephRBDMirrorsGetter
// }


// type Clientsets struct {
// 	// The Kubernetes config used for these client sets
// 	KubeConfig *rest.Config

// 	// Kube is a connection to the core Kubernetes API
// 	Kube kubernetes.Interface

// 	// Rook is a typed connection to the rook API
// 	Rook rookclient.Interface

// 	// Dynamic is used for manage dynamic resources
// 	Dynamic dynamic.Interface
// }



// func getClientsets(ctx context.Context) *Clientsets {
// 	var err error
// 	var kubeContext string
// 	clientsets := &Clientsets{}

// 	congfigOverride := &clientcmd.ConfigOverrides{}
// 	if kubeContext != "" {
// 		congfigOverride = &clientcmd.ConfigOverrides{CurrentContext: kubeContext}
// 	}

// 	// 1. Create Kubernetes Client
// 	kubeconfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
// 		clientcmd.NewDefaultClientConfigLoadingRules(),
// 		congfigOverride,
// 	)

// 	clientsets.KubeConfig, err = kubeconfig.ClientConfig()
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	clientsets.Rook, err = rookclient.NewForConfig(clientsets.KubeConfig)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	clientsets.Kube, err = k8s.NewForConfig(clientsets.KubeConfig)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	clientsets.Dynamic, err = dynamic.NewForConfig(clientsets.KubeConfig)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	return clientsets
// }

// // execCmdInToolPodDebug exec command on specific pod and wait the command's output.
// func execCmdInToolPodDebug(commandStr string)  (string, string, error)  {
// 	ctx := context.TODO()
// 	clientsets := getClientsets(ctx)
// 	podNamespace := "rook-ceph"
// 	clusterNamespace := "rook-ceph"
//     var stdout, stderr io.Writer = &bytes.Buffer{}, &bytes.Buffer{}
// 	returnOutput := true
// 	pods, err := clientsets.Kube.CoreV1().Pods(clusterNamespace).List(ctx, metav1.ListOptions{
// 		LabelSelector: "app=rook-ceph-tools",
// 	})
// 	if err != nil {
// 		return "a", "a", fmt.Errorf("failed to get ceph tool pod. %w", err)
// 	}
// 	cmd := strings.Fields(commandStr)
// 	podName := pods.Items[0].ObjectMeta.Name
// 	containerName := "rook-ceph-tools"

// 	// Prepare the API URL used to execute another process within the Pod.  In
// 	// this case, we'll run a remote shell.
// 	req := clientsets.Kube.CoreV1().RESTClient().
// 		Post().
// 		Namespace(podNamespace).
// 		Resource("pods").
// 		Name(podName).
// 		SubResource("exec").
// 		VersionedParams(&v1.PodExecOptions{
// 			Container: containerName,
// 			Command:   cmd,
// 			Stdout:    true,
// 			Stderr:    true,
// 			TTY:       false,
// 		}, scheme.ParameterCodec)

// 	exec, err := remotecommand.NewSPDYExecutor(clientsets.KubeConfig, "POST", req.URL())
// 	if err != nil {
// 		return "a", "a", fmt.Errorf("failed to create SPDYExecutor. %w", err)
// 	}

// 	// returnOutput is true, the command's output will be print on shell directly with os.Stdout or os.Stderr
// 	if !returnOutput {
// 		// Connect this process' std{in,out,err} to the remote shell process.
// 		err = exec.StreamWithContext(ctx, remotecommand.StreamOptions{
// 			Stdout: os.Stdout,
// 			Stderr: os.Stderr,
// 			Tty:    false,
// 		})
// 	} else {
// 		// Connect this process' std{in,out,err} to the remote shell process.
// 		err = exec.StreamWithContext(ctx, remotecommand.StreamOptions{
// 			Stdout: stdout,
// 			Stderr: stderr,
// 			Tty:    false,
// 		})
// 	}
// 	if err != nil {
// 		return "a", "a", fmt.Errorf("failed to run command. %w", err)
// 	}
// 	outputSting := stdout.(*bytes.Buffer)
// 	return outputSting.String(), "" , nil
// }


// // NewForConfig creates a new Clientset for the given config.
// // If config's RateLimiter is not set and QPS and Burst are acceptable,
// // NewForConfig will generate a rate-limiter in configShallowCopy.
// func NewForConfig(c *rest.Config) (*Clientset, error) {
// 	configShallowCopy := *c
// 	if configShallowCopy.RateLimiter == nil && configShallowCopy.QPS > 0 {
// 		if configShallowCopy.Burst <= 0 {
// 			return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
// 		}
// 		configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)
// 	}
// 	var cs Clientset
// 	var err error
// 	cs.cephV1, err = NewForConfigA(&configShallowCopy)
// 	if err != nil {
// 		return nil, err
// 	}

// 	cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(&configShallowCopy)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return &cs, nil
// }

// // NewForConfigOrDie creates a new CephV1Client for the given config and
// // panics if there is an error in the config.
// func NewForConfigOrDie(c *rest.Config) *CephV1Client {
// 	client, err := NewForConfig(c)
// 	if err != nil {
// 		panic(err)
// 	}
// 	return client
// }


// // NewForConfig creates a new CephV1Client for the given config.
// func NewForConfigA(c *rest.Config) (*CephV1Client, error) {
// 	config := *c
// 	if err := setConfigDefaults(&config); err != nil {
// 		return nil, err
// 	}
// 	client, err := rest.RESTClientFor(&config)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return &CephV1Client{client}, nil
// }


// func setConfigDefaults(config *rest.Config) error {
// 	gv := v1.SchemeGroupVersion
// 	config.GroupVersion = &gv
// 	config.APIPath = "/apis"
// 	config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()

// 	if config.UserAgent == "" {
// 		config.UserAgent = rest.DefaultKubernetesUserAgent()
// 	}

// 	return nil
// }


